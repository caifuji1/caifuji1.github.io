<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java并发编程 | Aspen</title><meta name="description" content="Java并发编程"><meta name="keywords" content="Java"><meta name="author" content="Aspen"><meta name="copyright" content="Aspen"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon1.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java并发编程"><meta name="twitter:description" content="Java并发编程"><meta name="twitter:image" content="https://caifuji1.github.io/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java并发编程"><meta property="og:url" content="https://caifuji1.github.io/2020/05/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="Aspen"><meta property="og:description" content="Java并发编程"><meta property="og:image" content="https://caifuji1.github.io/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://caifuji1.github.io/2020/05/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><link rel="prev" title="服务外包比赛" href="https://caifuji1.github.io/2020/06/03/%E6%9C%8D%E5%8A%A1%E5%A4%96%E5%8C%85%E6%AF%94%E8%B5%9B/"><link rel="next" title="JVM学习笔记" href="https://caifuji1.github.io/2020/05/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/my_.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fa fa-user-circle"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-user-circle"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Thread和Runnable的关系"><span class="toc-number">1.</span> <span class="toc-text">Thread和Runnable的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程上下文切换（Thread-Context-Switch）"><span class="toc-number">2.</span> <span class="toc-text">线程上下文切换（Thread Context Switch）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常见方法"><span class="toc-number">3.</span> <span class="toc-text">常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep和yield"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">sleep和yield</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程优先级"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#防止CPU占用-100"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">防止CPU占用 100%</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sleep实现"><span class="toc-number">3.0.0.3.1.</span> <span class="toc-text">sleep实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两阶段终止模式（Two-phase-Termination）"><span class="toc-number">3.0.0.4.</span> <span class="toc-text">两阶段终止模式（Two phase Termination）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不推荐使用的方法"><span class="toc-number">3.0.0.5.</span> <span class="toc-text">不推荐使用的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#守护线程"><span class="toc-number">3.0.0.6.</span> <span class="toc-text">守护线程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程状态"><span class="toc-number">4.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#共享模型之管程"><span class="toc-number">5.</span> <span class="toc-text">共享模型之管程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#竞态条件（Race-Condition）"><span class="toc-number">5.0.0.1.</span> <span class="toc-text">竞态条件（Race Condition）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常见线程安全类"><span class="toc-number">5.0.0.2.</span> <span class="toc-text">常见线程安全类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized"><span class="toc-number">6.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#偏向锁"><span class="toc-number">6.1.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#撤销"><span class="toc-number">6.1.1.</span> <span class="toc-text">撤销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#批量重偏向"><span class="toc-number">6.1.2.</span> <span class="toc-text">批量重偏向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#批量撤销"><span class="toc-number">6.1.3.</span> <span class="toc-text">批量撤销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁消除"><span class="toc-number">6.1.4.</span> <span class="toc-text">锁消除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wait和notify"><span class="toc-number">7.</span> <span class="toc-text">wait和notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-long-n-和-wait-long-n-的区别"><span class="toc-number">7.0.1.</span> <span class="toc-text">sleep(long n) 和 wait(long n) 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同步模式之保护性暂停"><span class="toc-number">8.</span> <span class="toc-text">同步模式之保护性暂停</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步模式之生产者-消费者"><span class="toc-number">9.</span> <span class="toc-text">异步模式之生产者&#x2F;消费者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#join原理"><span class="toc-number">10.</span> <span class="toc-text">join原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#park和unpark"><span class="toc-number">11.</span> <span class="toc-text">park和unpark</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多把锁"><span class="toc-number">12.</span> <span class="toc-text">多把锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#活跃性"><span class="toc-number">13.</span> <span class="toc-text">活跃性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#饥饿"><span class="toc-number">14.</span> <span class="toc-text">饥饿</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">15.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条件变量"><span class="toc-number">15.0.1.</span> <span class="toc-text">条件变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JMM"><span class="toc-number">16.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#指令重排"><span class="toc-number">16.0.0.0.1.</span> <span class="toc-text">指令重排</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同步模式之-Balking"><span class="toc-number">17.</span> <span class="toc-text">同步模式之 Balking</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#volatile原理"><span class="toc-number">18.</span> <span class="toc-text">volatile原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、如何保证可见性"><span class="toc-number">18.0.0.1.</span> <span class="toc-text">1、如何保证可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1、如何保证有序性"><span class="toc-number">18.0.0.2.</span> <span class="toc-text">1、如何保证有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#double-checked-locking-问题"><span class="toc-number">18.0.0.3.</span> <span class="toc-text">double-checked locking 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#happens-before"><span class="toc-number">18.0.0.4.</span> <span class="toc-text">happens-before</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程单例"><span class="toc-number">19.</span> <span class="toc-text">线程单例</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#无锁并发"><span class="toc-number">20.</span> <span class="toc-text">无锁并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么无锁效率高？"><span class="toc-number">20.0.1.</span> <span class="toc-text">为什么无锁效率高？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-的特点"><span class="toc-number">20.0.2.</span> <span class="toc-text">CAS 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子整数"><span class="toc-number">20.0.3.</span> <span class="toc-text">原子整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子引用"><span class="toc-number">20.0.4.</span> <span class="toc-text">原子引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子数组"><span class="toc-number">20.0.5.</span> <span class="toc-text">原子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字段更新器"><span class="toc-number">20.0.6.</span> <span class="toc-text">字段更新器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子累加器"><span class="toc-number">20.0.7.</span> <span class="toc-text">原子累加器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe"><span class="toc-number">20.0.8.</span> <span class="toc-text">Unsafe</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不可变类"><span class="toc-number">21.</span> <span class="toc-text">不可变类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#享元模式"><span class="toc-number">21.0.1.</span> <span class="toc-text">享元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无状态"><span class="toc-number">21.0.2.</span> <span class="toc-text">无状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池"><span class="toc-number">22.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造方法"><span class="toc-number">22.0.0.1.</span> <span class="toc-text">构造方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步模式之工作线程"><span class="toc-number">23.</span> <span class="toc-text">异步模式之工作线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#饥饿-1"><span class="toc-number">23.0.1.</span> <span class="toc-text">饥饿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Timer"><span class="toc-number">24.</span> <span class="toc-text">Timer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ForkJoin"><span class="toc-number">25.</span> <span class="toc-text">ForkJoin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReentrantLock-原理"><span class="toc-number">26.</span> <span class="toc-text">ReentrantLock 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读写锁"><span class="toc-number">27.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">27.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">27.1.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StampedLock"><span class="toc-number">27.2.</span> <span class="toc-text">StampedLock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Semaphore"><span class="toc-number">28.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CountdownLatch"><span class="toc-number">29.</span> <span class="toc-text">CountdownLatch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程安全的集合类"><span class="toc-number">30.</span> <span class="toc-text">线程安全的集合类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">31.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">32.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">33.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Aspen</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fa fa-user-circle"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-user-circle"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java并发编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-11 21:00:24"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-05-12 10:43:51"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-05-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/05/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>该文章主要用于记录Java并发编程的学习</p>
<p>一个类中只有一个抽象方法，他会加上@FunctionalInterface注解，可以使用lambda简化</p>
<h1 id="Thread和Runnable的关系"><a href="#Thread和Runnable的关系" class="headerlink" title="Thread和Runnable的关系"></a>Thread和Runnable的关系</h1><p>到时候运行都是走的Thread中的run方法</p>
<p>推荐使用Runnable的方法，把任务和线程分开</p>
<p>用Runnable更容易与线程池等高级API配合</p>
<p>用Runnable让任务类脱离了Thread继承体系，更灵活</p>
<p>FutureTask能够接受Callable类型的参数，用来处理有放回结果的情况，FutureTask也实现了Runnable接口，可以传给Thread</p>
<p>创建线程方式</p>
<ol>
<li>Thread</li>
<li>Thread和Runnable</li>
<li>FutureTask 配合Thread</li>
</ol>
<p>FutureTask 有个get方法，这个方法会等待FutureTask 返回的结果。就是阻塞</p>
<h1 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h1><p>因为一下一些原因导致CPU不在执行当前线程，去执行其他线程了</p>
<ul>
<li>线程时间片用完了</li>
<li>垃圾回收</li>
<li>有更高优先级的线程需要运行</li>
<li>自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当发生线程上下文切换时，需要由操作系统保存当前线程的状态，并恢复另一个县城的状态，Java对应的概念就是程序计数器（Program  Counter Register），它的作用就是记住下一条指定执行的地址（其实就是字节码指令），它是线程私有的</p>
<ol>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生回影响性能</li>
</ol>
<h1 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h1><table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>run()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>join()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>join(Long n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>inInterrupted()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>interrupted()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>currentThread()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sleep(long n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>yield()</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="sleep和yield"><a href="#sleep和yield" class="headerlink" title="sleep和yield"></a>sleep和yield</h4><p>sleep</p>
<ol>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li>
<li>其他线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 线程会抛出InterruptedException</li>
<li>睡眠结束后的进程未必会立刻执行</li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ol>
<p>yield</p>
<ol>
<li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其他线程</li>
<li>具体实现依赖于操作系统的任务调度器（比如说，如果这个时候就只有这个线程运行，任务调度器还是会把时间片分配给你）</li>
</ol>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅只是一个提示，调度器可以忽略它</li>
<li>如果CPU比较忙，那么优先级比较高的任务会有机会分配到更多的时间片，但CPU比较闲，优先级几乎没作用</li>
</ul>
<h4 id="防止CPU占用-100"><a href="#防止CPU占用-100" class="headerlink" title="防止CPU占用 100%"></a>防止CPU占用 100%</h4><h5 id="sleep实现"><a href="#sleep实现" class="headerlink" title="sleep实现"></a>sleep实现</h5><p>在没有利用CPU计算时，不要让while(ture)空转浪费CPU，这是可以使用yiedl或sleep来让出CPU的使用权</p>
<p>sleep、join、wait被打断后打断标记就会false，正常运行被打断true</p>
<p>正常运行的程序被打断后，只是告诉被打断了，还是在执行，所用要用打断标记判断是否被打断了，然后在停止程序运行</p>
<h4 id="两阶段终止模式（Two-phase-Termination）"><a href="#两阶段终止模式（Two-phase-Termination）" class="headerlink" title="两阶段终止模式（Two phase Termination）"></a>两阶段终止模式（Two phase Termination）</h4><p>在一个线程T1中如何“优雅”终止线程T2。就是不是马上直接终止T2，让T2有一个料理后事的机会</p>
<p>使用stop（）方法会真正杀死线程，如果此时线程锁住了共享资源， 那么其他线程将无法获取锁</p>
<p>使用System.exit(int)方法停止线程，目的停止一个线程，但这种做法会让整个程序停止。进程停止</p>
<p>IsInterrupted()不会清除打断标记，interrupted()会清除打断标记</p>
<p>LockSupport.park()，interrupt会打断park线程，之后park就不生效了，可以使用interrupted()清除打断标记重置为false就又可以生效了</p>
<h4 id="不推荐使用的方法"><a href="#不推荐使用的方法" class="headerlink" title="不推荐使用的方法"></a>不推荐使用的方法</h4><p>这些方法已经过时，容易破坏同步代码块，造成线程死锁</p>
<p>stop    停止线程运行</p>
<p>suspend    挂起（暂停）线程运行</p>
<p>resume    恢复线程运行</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>java进程需要等待所有线程都运行结束后才会结束。守护线程就是只要其他非守护线程运行结束了，即使守护线程的代码没有运行完，也会强制结束</p>
<p>线程启动前调用setDaemon(true)就能开启守护线程</p>
<p>注意：</p>
<ol>
<li>垃圾回收器就是守护线程，如果你的程序停止了，垃圾回收线程也会被强制停止</li>
<li>Tomcat中的 Acceptor 和 Poller 线程都是守护进程（它们是用来Tomcat接收请求和分发请求的线程），所以 Tomact 接受到shutdown 命令后，不会等待它们处理完当前请求</li>
</ol>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>5种状态，是从操作系统的角度，初始状态、就绪状态、运行状态、终止状态、阻塞状态</p>
<p>6种状态，是从Java API层面，根据Thread.State枚举，分为6种状态</p>
<ul>
<li>NEW 线程刚被创建，没有调用start（）方法</li>
<li>RUNNAGLE包括了就绪、运行、阻塞</li>
<li>TERMINATED终止</li>
<li>BLOCKED,WAITING(join),TIMED_WAITING(sleep) 都是 Java API 层面对【阻塞状态】的细分</li>
</ul>
<h1 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h1><p>上下文切换，导致线程安全问题</p>
<p>一块代码内存在对共享资源的多线程读写，这个代码区就叫临界区</p>
<h4 id="竞态条件（Race-Condition）"><a href="#竞态条件（Race-Condition）" class="headerlink" title="竞态条件（Race Condition）"></a>竞态条件（Race Condition）</h4><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p>
<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的</p>
<ul>
<li>阻塞式：synchronized、Lock</li>
<li>非阻塞式：原子变量</li>
</ul>
<p>synchronized实际上是用了对象锁保证了临界区内代码的原子性</p>
<p>加方法上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h4><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.comcurrent 包下的类</li>
</ul>
<p>是指多个进程调用它们同一个实例的某个方法时，是线程安全的，也可以这样理解</p>
<ul>
<li>它们每个方法是原子的</li>
<li>它们多个方法的组合不是原子的</li>
</ul>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>自旋优化</p>
<ul>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么人物这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能</li>
<li>自旋会占用CPU时间，单核CPU自旋就是浪费时间，多核CPU自旋才能发挥优势</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>把ThreadID记录到markword中</p>
<ul>
<li>默认开启偏向锁</li>
<li>偏向锁是默认延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟</li>
<li>如果没开启偏向锁，那么对象创建后 ，markword 值为0X01 即最后 3 位位001，这时它的 hashcod、age 都为0，第一次用到 hashcod 时才会赋值</li>
</ul>
<p>-XX:-UseBiasedLocking 禁用偏向锁（use前面这个-号表示关闭，+号表示开启）</p>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ol>
<li>当一个可偏向的对象调用hashcode的时候，会撤销它的偏向状态。（存不下了。。。）</li>
<li>其他线程使用这个对象的时候，锁会撤销升级成轻量级锁</li>
<li>调用 wait/notify     这个是重量级锁才有的</li>
</ol>
<h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</p>
<p>当撤销偏向锁阈值超过 20 次后（第20次就开始了），jvm 会觉得，是不是偏向错了，于是会再给这些对象加锁时重新偏向至加锁线程</p>
<h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><p>当撤销偏向锁阈值超过 40 次后（第40次就开始了），jvm 会觉得偏向错了，根本就不应该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JIT优化</p>
<p>-XX:-EliminateLocks 锁消除开关，默认是打开的</p>
<h1 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h1><p>让已经进入监视器的线程到waitSet等待，notify唤醒一个（随机），notifyAll全部唤醒</p>
<p>必须要成为owner才能用</p>
<p>这些方法都是Object中的方法</p>
<p>wait中有带2个参数的方法，第一个参数是毫秒，第二个是纳秒，第二个参数实际上只是把第一个参数加一，然后再去调用一个参数的wait（毫秒）</p>
<p>虚假唤醒，因为notify是随机唤醒一个，可能会叫醒其他的线程，可以使用notifyAll。可以配合while使用</p>
<h3 id="sleep-long-n-和-wait-long-n-的区别"><a href="#sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="sleep(long n) 和 wait(long n) 的区别"></a>sleep(long n) 和 wait(long n) 的区别</h3><ol>
<li>sleep 是 Thread 方法，而 wait 是Object 的方法</li>
<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用</li>
<li>sleep 在睡眠的同时，不会释放对象锁，但 wait 在等待的时候会释放对象锁</li>
</ol>
<p>但他们的状态都是一样的TIMED_WAITING</p>
<h1 id="同步模式之保护性暂停"><a href="#同步模式之保护性暂停" class="headerlink" title="同步模式之保护性暂停"></a>同步模式之保护性暂停</h1><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<p>要点</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<h1 id="异步模式之生产者-消费者"><a href="#异步模式之生产者-消费者" class="headerlink" title="异步模式之生产者/消费者"></a>异步模式之生产者/消费者</h1><p>要点</p>
<ul>
<li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和西欧爱妃结果的线程一一对应</li>
<li>消费队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会在加入数据，空时不会在消耗数据</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<h1 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h1><p>底层就是用wait来实现的</p>
<h1 id="park和unpark"><a href="#park和unpark" class="headerlink" title="park和unpark"></a>park和unpark</h1><p>他们是 LockSupport 类中的方法</p>
<p>park后线程状态是WAIT</p>
<p>unpark可以在线程暂停前，也可以在暂停后调用</p>
<p>特点</p>
<p>与 Object 的 wait 和 notify 相比</p>
<ul>
<li>wait，notify和notifyAll 必须配合 Object Monitor 一起使用，而 unpark 不必</li>
<li>park 和 unpark 是以线程为单位来阻塞和唤醒线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确了</li>
<li>park 和 unpark 可以先 unpark，而 wait 和 notify 不能先 notify</li>
</ul>
<ol>
<li>当前线程调用park方法</li>
<li>检查_counter，本情况为 0，这是，获得 _mutex 互斥锁</li>
<li>线程进入 _cond 条件变量阻塞</li>
<li>设置 _counter = 0</li>
</ol>
<ol>
<li>调用 uppark 方法，设置 _counter 为 1</li>
<li>唤醒 _cond 条件变量中的 Thread_0</li>
<li>Thread_0 恢复运行</li>
<li>设置 _counter 为 0</li>
</ol>
<ol>
<li>调用 Unsafe. unpark( Thread0)方法,设置 counter为1</li>
<li>当前线程调用 Unsafe. park0方法</li>
<li>检查 counter,本情况为1,这时线程无需阻塞,继续运行</li>
<li>设置 counter为0</li>
</ol>
<h1 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h1><p>将锁的粒度细分</p>
<ul>
<li>好处，可以增强并发度</li>
<li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li>
</ul>
<h1 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h1><p>1、死锁</p>
<p>检测死锁可以使用 jcortsole工具,或者使用jps定位进程id,再用 stack定位死锁</p>
<p>2、活锁</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/caifuji1/picbed/images/image-20200721143658760.png" alt="image-20200721143658760"></p>
<p>解决：增加一些随机的睡眠时间</p>
<h1 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h1><p>一个线程优先级太低，始终得不到CPU调度执行，也不能结束</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>相对与 synchronized 它具备如下特点</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量（就是那个waitSet能有多个，等待的线程会到waitSet中）</li>
</ul>
<p>与 synchronized 一样，支持锁重入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lick = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>lock()不可打断</p>
<p>lockInterruptibly()可打断</p>
<p>tryLock()尝试获得锁（避免长时间等待）还能加参数例如：tryLock(1,TimeUnit.SECONDES)</p>
<p>另外它也支持可打断</p>
<p>公平锁一般没有必要设置，会降低并发度</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ReentrantLock Lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个新的条件变量(体息室)</span></span><br><span class="line">	Condition condition1 = <span class="function">Lock <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">	Condition condition2 = <span class="function">Lock <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">    Lock.lock();</span><br><span class="line">    <span class="comment">//进入休息室等待</span></span><br><span class="line">    condition1.await();</span><br><span class="line">    conditionl.signal();</span><br><span class="line">    condition1.signalAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用流程</p>
<ul>
<li>await前需要获得锁</li>
<li>await执行后,会释放锁,进入 conditionObject 等待</li>
<li>await的线程被唤醒(或打断、或超时)取重新竞争lock锁</li>
<li>竞争lock锁成功后,从 await后继续执行</li>
</ul>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>可见性                volatile用来修饰成员变量和静态成员变量</p>
<p>volatile不能保证原子性</p>
<p>println方法中有synchronized修饰</p>
<p>有序性</p>
<h5 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h5><p>CPU层面</p>
<p>事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的CPU指令。因为指令还可以划分成一个个更小的阶段。例如，每条指令都可以分为：取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 这5个阶段</p>
<ul>
<li>instruction fetch (IF)</li>
<li>instruction decode (ID)</li>
<li>execute (EX)</li>
<li>memory access (MEM)</li>
<li>register write back (WB)</li>
</ul>
<p>同样在java层面也有指令重排的优化</p>
<p>加上volatile能防止之前的变量发生指令重排序</p>
<h1 id="同步模式之-Balking"><a href="#同步模式之-Balking" class="headerlink" title="同步模式之 Balking"></a>同步模式之 Balking</h1><p>Balking （犹豫） 模式用在咏鹅线程发现另一个线程或本县城已经做了某一件事，那么本线程就无需再做了，直接结束返回</p>
<h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><p>volatile 的底层实现原理是内存屏障，Memory Barrier （Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<h4 id="1、如何保证可见性"><a href="#1、如何保证可见性" class="headerlink" title="1、如何保证可见性"></a>1、如何保证可见性</h4><p>写屏障保证该屏障之前的，对共享变量的改动，都同步到主存当中</p>
<p>读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p>
<h4 id="1、如何保证有序性"><a href="#1、如何保证有序性" class="headerlink" title="1、如何保证有序性"></a>1、如何保证有序性</h4><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
<p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
<p>注意，原子性时保证不了的。而synchronized都能做到</p>
<p>final 关键字，就是在在写之后加入了写屏障</p>
<h4 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a>double-checked locking 问题</h4><p>以著名的 double-checked locking 单例模式为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用 genInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
<li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，实在同步块之外但在多线程环境下，上面的代码是有问题的</li>
</ul>
<p>只有对象完全受synchronized保护才能完全保证有序性、原子性、可见性</p>
<p>修改后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                	INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><ol>
<li>线程解锁m之前对变量的写,对于接下来对m加锁的其它线程对该变量的读可见</li>
<li>线程对 volatile变量的写,对接下来其它线程对该变量的读可见</li>
<li>线程start前对变量的写,对该线程开始后对该变量的读可见</li>
<li>线程结束前对变量的写,对其它线程得知它结束后的读可见(比如其它线程调用 t1.isAlive()或 t1.join()等待它结束)</li>
<li>线程 t1 打断 t2 （interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见</li>
<li>对变量默认值（0，false，null）的写，对其他线程对该变量的读可见</li>
<li>传递性</li>
</ol>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/caifuji1/picbed/images/image-20200722121434443.png" alt="image-20200722121434443"></p>
<h1 id="线程单例"><a href="#线程单例" class="headerlink" title="线程单例"></a>线程单例</h1><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类</p>
<p>饿汉式：类加载就会导致该单实例对象被创建</p>
<p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会被创建</p>
<h1 id="无锁并发"><a href="#无锁并发" class="headerlink" title="无锁并发"></a>无锁并发</h1><p>CAS操作需要 volatile 的支持，这样才能读到共享变量的最新值</p>
<h3 id="为什么无锁效率高？"><a href="#为什么无锁效率高？" class="headerlink" title="为什么无锁效率高？"></a>为什么无锁效率高？</h3><ul>
<li>无锁情况下，即使重试失败，线程始终都在高速运行，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞</li>
<li>线程就好像高速跑道上的赛车,高速运行时,速度超快,一旦发生上下文切换,就好比赛车要减速、熄<br>火,等被唤醒又得重新打火、启动、加速…·恢复到高速运行,代价比较大</li>
<li>但无锁情况下,因为线程要保持运行,需要额外CPU的支持,CPU在这里就好比高速跑道,没有额外的<br>跑道,线程想高速运行也无从谈起,虽然不会进入阻塞,但由于没有分到时间片,仍然会进入可运行状<br>态,还是会导致上下文切换。</li>
</ul>
<h3 id="CAS-的特点"><a href="#CAS-的特点" class="headerlink" title="CAS 的特点"></a>CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，使用于线程数少、多核 CPU 的场景下</p>
<ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，重试呗</li>
<li>synchronized是基于悲观锁的思想:最悲观的估计,得防着其它线程来修改共享变量,我上了锁你们都别<br>想改,我改完了解开锁,你们才有机会。</li>
<li>CAS体现的是无锁并发、无阻塞并发,请仔细体会这两句话的意思<ul>
<li>因为没有使用 synchronized,所以线程不会陷入阻塞,这是效率提升的因素之一</li>
<li>但如果竞争激烈,可以想到重试必然频繁发生,反而效率会受影响</li>
</ul>
</li>
</ul>
<h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><p>J.U.C 并发包提供了：</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference   值，还有个布尔值</li>
<li>AtomicStampedReference   不光比较值，还要比较时间戳</li>
</ul>
<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><ul>
<li>AtomicIntegerArray   保护数组内的元素是整形</li>
<li>AtomiicLongArray   保护数组内的元素是长整形</li>
<li>AtomicReferenceArray   保护数组内的元素是引用类型的</li>
</ul>
<h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul>
<li>AtomicReferenceFieldUpdater</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>
<p>保护的是对象中的属性，这个属性要使用 volatile 修饰，否则会出现异常（IllegalArgumentException）</p>
<p>因为CAS要保证共享变量的可见性</p>
<h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><p>LongAdder等等</p>
<p>比使用AtomicLong进行累加性能更好</p>
<p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Thread-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]…最后将结果汇总。这样他们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/caifuji1/picbed/images/image-20200722160959246.png" alt="image-20200722160959246"></p>
<p>其中 Cell 即为累加单元</p>
<p>底层实现加上了@sun.misc.Contended注解（防止缓存行伪共享）原理是对使用这个注解的对象或字段的前后各加 128 字节大小的 padding（空白），差不多就是用空间换时间</p>
<p>就是防止一个缓存行容纳多个 Cell 对象</p>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p>
<p>CAS、LockSupport 底层都是调用了 Unsafe</p>
<h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p>simpletimeformat    内部变量可变，多线程下不安全</p>
<p>datatimeformatter    不可变</p>
<p>String类的设计，为了保证对象的不可变性，采用了保护性拷贝</p>
<p>因此就会发生对象的频繁创建问题。所以采用了享元模式的设计模式</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>定义：Flyweigth pattern。当需要重用数量有限的同一类对象时。</p>
<p>包装类基本都采用了这种模式，ValueOf的实现</p>
<p>Byte，Short，Long 缓存的范围都是-128~127</p>
<p>Character 缓存的范围是 0~127</p>
<p>Integer 的默认范围是 -128-127，最小值不能改变，最大值可以通过调整虚拟机参数</p>
<p>-Djava.langInteger.IntegerCache.high 来改变</p>
<p>Boolean 缓存了 TRUE 和 FALSE</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>没有成员变量，所以是线程安全的</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/caifuji1/picbed/images/image-20200723110315281.png" alt="image-20200723110315281"></p>
<p>这些信息存放在一个 int 中，只用一次cas操作就能改变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值，ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c,ctlOf(targetState,workerCountOd(c)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// rs 为 高 3 位代表线程池状态，wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs,<span class="keyword">int</span> wc)</span></span>&#123; <span class="keyword">return</span> rs | wc;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize,</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">    TimeUnit unit,</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">    ThreadFactory threadFactory,</span><br><span class="line">    RejectedExecutionHandler handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize 核心线程数（最多保留的线程数）</li>
<li>maximumPoolSize 最大线程数</li>
<li>keepAliveTime 生存时间 - 针对救急线程</li>
<li>unit 时间单位 - 针对救急线程</li>
<li>workQueue 阻塞队列</li>
<li>threadFactory 线程工厂 - 可以为线程创建时起名字</li>
<li>handler 拒绝策略</li>
</ul>
<p>救急线程有生存时间，核心线程没有</p>
<p>所有线程都在工作（包括救急线程），此时再来一个任务才会执行策略</p>
<p>救急要配合有界队列，任务超过有界队列大小时，会创建救急线程来救急</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/caifuji1/picbed/images/image-20200723140126182.png" alt="image-20200723140126182"></p>
<ul>
<li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li>
<li>CallerRunsPolicy 让调用者运行任务</li>
<li>DiscardPolicy 放弃本次任务</li>
<li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取代</li>
</ul>
<ul>
<li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录入职，并 dump 线程栈信息，方便定位问题</li>
<li>Netty 的实现，创建一个新的线程来执行（达不到限制线程总数的目的）</li>
<li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列</li>
<li>PinPoint 的实现，它使用了一个拒绝策略链，就是可以组合多种策略</li>
</ul>
<ul>
<li>newFixedThreadPool  固定大小线程池</li>
<li>newCachedThreadPool 带缓冲的线程池，创建的线程全是救急线程60s后会被回收。没有容量限制，可以被无限创建<ul>
<li>他的队列采用了 SynchronousQueue 实现，特点是没有容量，就是没有线程执行任务，那么任务就放不进去</li>
</ul>
</li>
<li>newSingleThreadExecutor 单线程池，线程数是 1 ，会放入无界队列。适用于多个任务排队执行<ul>
<li>自己创建一个单线程串行执行任务,如果任务执行失败而终止那么没有任何补救措施,而线程池还会新建一个线程,保证池的正常工作</li>
<li>Executors. newSingleThreadExecutor()线程个数始终为1,不能修改<ul>
<li>FinalizableDelegatedExccutorService 应用的是装饰器模式,只对外暴露了 ExccutorService接口,因此不能调用 ThreadPoolExecutor(1)中特有的方法</li>
</ul>
</li>
<li>Executors. new FixedThreadPool(1)初始时为1,以后还可以修改<ul>
<li>对外暴露的是 ThreadPoolExecutor对象,可以强转后调用 setCorePoolsize等方法进行修改</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/caifuji1/picbed/images/image-20200723145327031.png" alt="image-20200723145327031"></p>
<p>submit来实现有返回结果的任务，Future就是使用了保护性暂停模式，来接收另一个线程的返回结果</p>
<p>另外这个也是单方法的接口，可以使用lambda表达式简化</p>
<p>invokeAll 接收的的是集合多个任务，返回的也是集合</p>
<p>invokeAny 多个任务中的一个最先完成就提交，其他任务取消。返回结果就和前面不一样了是 Object</p>
<p>shutdown：</p>
<ul>
<li>线程池状态变为SHUTDOWN</li>
<li>不会接收新的任务</li>
<li>会把已提交的任务做完</li>
<li>这个方法不会阻塞调用这个方法的线程</li>
</ul>
<p>shutdownNow：</p>
<ul>
<li>线程池状态变为STOP</li>
<li>不会接收新的任务</li>
<li>队列中的任务返回</li>
<li>用 interrupt 方法打断正在执行的任务</li>
</ul>
<p>List<Runnable> shutdownNow();</p>
<p>isShutdow() 判断是否调用了shutdown方法，不是RUNNING状态的都返回true</p>
<p>isTerminated()  线程池是否Terminated</p>
<p>awaitTermination() 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果想在线程池TERMINATED后做些事情，可以用这个方法</p>
<h1 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h1><p>让有限的工作线程（Work Thread）异步处理任务</p>
<h3 id="饥饿-1"><a href="#饥饿-1" class="headerlink" title="饥饿"></a>饥饿</h3><p>使用固定大小的线程池会有饥饿现象，单线程池也有。缓冲没有</p>
<p>这种是线程不足导致的饥饿现象</p>
<p>例子：2个线程，都去执行前置任务，他们都需要后置任务的返回结果，现在由于线程不足没法执行后置任务，然后执行前置任务的线程就一直等着了</p>
<p>解决：不同的任务使用不同的线程池</p>
<p>创建多少线程池合适？</p>
<ol>
<li>CPU密集型运算   CPU核数+1</li>
<li>I/O密集型运算   线程数 = 核数 * 期望 CPU 利用率 * 总时间（CPU计算时间 + 等待时间） 、 CPU 计算时间</li>
</ol>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>这个是串行执行的，前面任务慢了，后面都得满。要是出现异常，没捕捉，后面全挂了</p>
<p>这个是过时的，不推荐使用</p>
<p>改进使用</p>
<p>任务调度的线程池</p>
<p>ScheduledExecutorService pool = Excutors.newScheduledThreadPool(线程数);</p>
<p>出现异常，照样执行</p>
<p>而且调度线程时可以延时执行任务，还能定时执行</p>
<p>异常处理</p>
<ol>
<li>主动处理 try-catch</li>
<li>Callable 配合 Future 能够获得异常</li>
</ol>
<h1 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h1><p>fork执行任务，join获取任务结果</p>
<p>分治思想、创建和CPU核心数相同的线程</p>
<p>这个时候就不能用Runnable这些任务</p>
<p>用RecursiveTask 有返回类型   RecursiveTask 没有返回</p>
<p>和递归差不多</p>
<p>主要还是看你的任务如何拆分，拆的好就快</p>
<h1 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h1><p>锁重入原理就是对状态state++，解锁就减直到减为零</p>
<p>可打断原理（默认不可打断）不可打断的方式就重置了打断标记为true，可打断的抛出了一个异常</p>
<p>公平锁实现，会去aqs队列中是否有前驱结点，当前线程是不是老二的那个节点</p>
<p>条件变量的实现原理，线程加入ConditionObject ，然后调用fullRelease（因为可能出现锁重入，所用不用release）把状态变为0</p>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>都是读操作可以并发，读写的话就互斥</p>
<p>读锁不支持条件变量，写锁支持</p>
<p>重入时升级不支持：即持有读锁的情况下获取写锁，会导致获取写锁永久等待</p>
<p>重入时降级支持：即持有写锁的情况下获取读锁</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>读写锁用的时同一个 Sycn 同步器，因此等待队列、state 等也是同一个</p>
<p>state 低 16 位给写锁用，高 16 位给读锁用</p>
<p>进入等待队列读锁线程是shared（共享），写锁线程时Ex（独占）</p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>JDK 8 加入，为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用加解读锁</p>
<p>tryOptimisticRead乐观读，失败了后进行锁升级，升级成读锁</p>
<p>缺点：</p>
<ol>
<li>不支持条件变量</li>
<li>不支持可重入</li>
</ol>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>信号量，用来限制能同时访问共享资源的线程数</p>
<h1 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h1><p>用来进行线程同步协作，等待所有线程完成倒计时</p>
<p>应用：等其他线程运行好后，在开始这个线程。（比如多人游戏）</p>
<p>需要在主线程中获取其他线程的结果时，这时候就得使用 future</p>
<p>CountdownLatch只能在创建构造方法的时候赋予初值，而且不能重用</p>
<p>如果需要让任务循环多次这就需要使用 CyclicBarrier 他有2个参数，第一个数倒计时，第二个时任务（用来做其他任务后的汇总）</p>
<p>计数变为0后下次调用它又会重置，所以可以重用，避免了对象重复创建的问题</p>
<p>注意：线程数和计数要一致，这样才能达到效果</p>
<h1 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/caifuji1/picbed/images/image-20200724152726189.png" alt="image-20200724152726189"></p>
<h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><p>入队操作 last = last.next = node</p>
<p>LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p>
<ul>
<li>Linked 支持有界， Array 强制有界</li>
<li>Linked 实现是链表， Array 是数组</li>
<li>Linked 懒惰的， Array 需要提前初始化 Node 数组</li>
<li>Linked 每次入队会生成新的 Node， Array 的Node 是提前创建好的</li>
<li>Linked 两把锁， Array 一把锁</li>
</ul>
<h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><p>和上面的很像，不过锁使用cas实现的</p>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>CopyOnWriteArraySet 是它的马甲。这里面方法是调用了 CopyOnWriteArrayList 中的方法。</p>
<p>底层实现采用了写入时拷贝的思想，读读、读写都是并发的，只有写写是互斥的</p>
<p>适合读多写少的场景</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Aspen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://caifuji1.github.io/2020/05/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">https://caifuji1.github.io/2020/05/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://caifuji1.github.io" target="_blank">Aspen</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/03/%E6%9C%8D%E5%8A%A1%E5%A4%96%E5%8C%85%E6%AF%94%E8%B5%9B/"><img class="prev_cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">服务外包比赛</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next_cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/04/23/毕业设计总结/" title="毕业设计总结"><img class="relatedPosts_cover "src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-04-23</div><div class="relatedPosts_title">毕业设计总结</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '722a85efaac07df74b69',
  clientSecret: 'a75c9152b7b73d0851c44e6d42a7e56256c9ba48',
  repo: 'my-gitalk',
  owner: 'caifuji1',
  admin: ['caifuji1'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" style="background-image: url(/img/post.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Aspen</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://caifuji1.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>